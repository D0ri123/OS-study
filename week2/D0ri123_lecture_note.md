## 2주차 스터디 정리

### 1. 프로세스란?
- 실행하고 있는 프로그램을 말하며, 프로그램 명령어와 데이터들이 메모리에 올라가고 실행 중 또는 실행 대기중인 상태를 말한다.

---

### 2. 프로세스 문맥(context)
- 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보이다.
- 왜 필요할까? 
  - 현대의 운영체제인 시분할 시스템 환경에서 다시 명령을 수행하려면 이전에 어디까지 수행하였는지 정확한 수행시점과 상태를 재현할 수 있는 정보가 필요하기 때문이다.
- 프로세스 문맥은 **1. 하드웨어 문맥 , 2. 프로세스의 주소공간, 3.커널 상의 문맥**으로 이뤄져 있다.
    - 하드웨어 문맥 : CPU 수행상태를 나타낸다. Program Counter(PC), 각종 Registers에 저장하고 있는 값들이다.
    - 프로세스의 주소공간 : 프로세스만의 독자적인 주소공간이며 **코드, 데이터, 스택**을 말한다.
    - 커널 상의 문맥 : 프로세스 관리를 위한 자료구조이며, PCB와 커널 스택이 있다.

---
### 3. 프로세스 상태(중기 스케줄러가 있기 전)
- 프로세스의 상태 전이 : 하나의 프로세스는 프로그램으로부터 만들어져(생성) 주기억장치로 들어오고, CPU에 할당되기 위해 준비한다. 이후에 CPU에 할당되어 필요한 모든 실행을 마치면 종료된다.
  - **Running(실행)** : CPU를 잡고 instruction을 수행중인 상태이다.
  - **Ready(준비)** : 메모리 등 다른 조건을 모두 만족하고 CPU만 기다리고 있는 상태이다. 프로세스들은 자신의 우선순위를 지니고 있으며, 가장 높은 우선순위의 프로세스가 가장 먼저 CPU를 할당받는다.
  - **Blocked(대기)** : CPU를 줘도 당장 instruction을 수행할 수 없는 상태이다. 우선순위가 없이 조건이 만족되면 Ready 상태로 전환된다. 큐를 통해 순차적으로 순서가 결정된다.
  - New : 프로세스가 생성중인 상태
  - Terminated : 수행이 끝난 상태이다. 해당 PCB가 삭제된다.
  
![image](https://user-images.githubusercontent.com/94590894/187186605-ee42dc42-a637-4f7e-983b-831b731a65c0.png)

  - scheduler dispatch? 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태를 말한다.

---
### 4. PCB(Process Control Block)
- 운영체제가 프로세스를 표현한 것으로, 운영체제의 커널 부분에 있다. **프로세스를 관리하기 위한 자료구조로 프로세스에 대한 정보를 지니고 있는 테이블이다.** 하나의 프로세스가 생성되면 해당 프로세스의 PCB가 만들어지고, 프로세스가 종료되면 함께 사라진다.

![image](https://user-images.githubusercontent.com/94590894/187188301-5370b496-e010-4582-b597-453693cab585.png)

---
### 5. 문맥 교환(Context Switch)
- **CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정.** 즉 CPU에게 할당되는 프로세스가 교체되는 것을 말한다.
- CPU가 다른 프로세스로 넘어갈 때 운영체제는
  1. CPU를 내어주는 프로세스의 문맥을 그 프로세스의 PCB에 저장한다.
  2. CPU를 새롭게 얻는 프로세스의 문맥을 PCB로부터 읽어 실제 하드웨어로 복원한다.
- **잦은 문맥 교환은 오버헤드가 되어 성능을 저하시키는 원인이 된다.**
- System call이나 Interrupt 발생시 반드시 context switch(프로세스 A -> 프로세스 B)가 일어나는 건 아니다.
  1. 문맥교환이 아닌 경우
     1. 사용자 프로세스 A - Interrupt or System call - 커널 모드 - 문맥교환없이 user모드 복귀 - 사용자 프로세스 A
  2. 문맥교환
     1. 사용자 프로세스 A - Interrupt or I/O요청 System call - 커널 모드 - 문맥 교환 발생 - 사용자 프로세스 B
  - 문맥교환이 아닌 경우에도 PCB에 저장을 해야하지만 문매교환인 경우에는 과정 중에 cache memory flush가 일어나는 등 부담이 훨씬 크다.

---
### 6. 프로세스를 스케줄링하기 위한 큐
- Job queue : 현재 시스템 내에 있는 모든 프로세스의 집합이다.
- Ready queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합이다.
- Device queues : I/O device의 처리를 기다리는 프로세스의 집합이다.
- ***프로세스들은 각 큐들을 오가며 수행된다.***
![image](https://user-images.githubusercontent.com/94590894/187193123-31a720e6-b106-48e7-b960-bd7d670b2ff2.png)

---
### 7. 스케줄러(Scheduler)
- **Long-term Scheduler(장기 스케줄러 or job scheduler)**
  - 시작 프로세스 중 어떤 것들을 Ready queue에 보낼지 결정한다.
  - 프로세스에 memory 및 각종 자원을 주는 문제를 담당한다.
  - 동시에 몇 개의 프로그램을 수행할 지 제어한다.(degree of Multiprogramming을 제어)
  - Time Sharing System에는 보통 장기 스케줄러가 없다.(현대 운영체제에 사용되지 않는다. 하드웨어 발전으로 무조건 ready 상태로 올리는 것이 가능해졌다.)
   ![image](https://user-images.githubusercontent.com/94590894/187194220-c29d6fdd-2731-4345-8282-e935005eb117.png)
  - new 상태에서 ready 상태로 바꾸는 과정에서 admitted 해주는 역할을 한다.

- **Short-term Scheduler(단기 스케줄러 or CPU scheduler)**
  - Ready queue에 있는 프로세스들 중 다음 번에 running 시킬 프로세스를 결정한다.
  - 즉, 프로세스에 CPU를 할당하는 역할을 한다.
  - 매우 빈번하게 호출되므로 빨라야 한다.

- **Medium-term Scheduler(중기 스케줄러 or Swapper)**
  - 현대 운영체제(Time Sharing System)에서 장기 스케줄러 사용이 낮아지면서 중기 스케줄러를 사용한다.
  - 많은 프로세스에게 메모리를 할당해서 시스템의 성능이 저하되는 일을 조절한다.(너무 많아도 혹은 너무 없어도 성능이 저하됨)
  - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크의 swap 영역으로 저장한다.(=swap out, 프로세스에게서 메모리를 빼앗는다)
  - 그래도 여유공간이 마련되지 않는다면, Ready queue로 이동하는 프로세스를 추가적으로 swap out한다.
  - 장기 스케줄러와 유사하게 degree of Multiprogramming을 제어한다.
  - 중기 스케줄러로 인하여 추가된 프로세스 상태(=Suspended)가 있다.
    - Suspended(stopped)
      - 외부적인 이유(공간 마련)로 프로세스의 수행이 정지된 상태
      - 프로세스는 통째로 디스크(swap area)에 swap out된다.
      - ex : 사용자가 프로그램을 일시 정지시킨 경우. 메모리에 너무 많은 프로세스가 올라와 있을 때
        ![image](https://user-images.githubusercontent.com/94590894/187196642-4320f87c-aebd-4058-8861-68700e7aec18.png)
      - Suspended와 Blocked의 차이점 : Blocked는 자신이 요청한 event가 만족되면 ready상태로 변경된다. Suspended는 외부에서 resume해줘야 Active가 된다.
      - Suspended 상태에서도 요청한 event가 완료되면 blocked에서 ready상태로 전환될 수 있다.

---
### 8.스레드(Thread, lightweight process)
- 스레드란?
  - 프로세스 내에서 CPU의 수행단위를 말하며, 실제로 작업을 수행하는 주체이다.
  - 모든 프로세스에는 한 개 이상의 스레드가 존재한다. 
  - 독립적인 실행이 가능하며, 독립적으로 스케줄링이 된다. 프로세스 단위로 운영되는 것보다 더 발전된 운영체제 개념이다. 
- 스레드 구성
  - 스레드는 고유한 스레드 ID, Program counter, register set, stack을 가진다.
  - 스레드 간에 code와 data, file을 공유한다.
    ![image](https://user-images.githubusercontent.com/94590894/187418774-723e8da8-300c-4359-b63e-c0f346609789.png)
- 스레드 분류
  1. 사용자 수준의 스레드
     - 사용자가 만든 라이브러리를 사용하여 운용된다. 속도는 빠르지만, 구현이 어렵다. 커널이 프로세스 내부의 스레드를 인식하지 못하기 때문에 하나의 스레드가 시스템 호출로 중단되면 나머지 모든 스레드 역시 중단되는 단점이 있다.
  2. 커널 수준의 스레드
     - 운영체제의 커널에 의해 운용된다. 구현은 쉬우나, 속도가 느리다. 스레드 하나가 중단되더라도 커널은 다른 스레드를 중단시키지 않고 계속 실행시켜준다.
- 스레드 장점
  - **병행성** : 다중 스레드로 구성되면, 하나의 스레드가 blocked 상태인 동안에도 동일한 태스크의 다른 스레드가 실행되어 빠른 처리를 할 수 있다. 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.
  - **응답성 향상** : 응용 프로그램의 응답시간을 단축시킨다.
  - **자원 낭비 절감** : 실행 환경을 공유하여 메모리 공간의 낭비를 줄인다.
  - **오버헤드 감소** : 프로세스 생성, 교체보다 스레드 생성, 교체의 부담이 훨씬 적다.
  - **통신 향상**

---
### 9. 프로세스 생성
- 부모 프로세스가 자식 프로세스를 생성하며, 이로 인해 트리 구조가 형성된다.
- 생성된 프로세스는 자원을 필요로 하는데
  1. 운영체제로부터 받거나
  2. 부모와 공유한다.
- 자원 공유 case
  - 부모와 자식이 모든 자원을 공유한다.
  - 일부만 공유한다.
  - **전혀 공유하지 않는다.(대부분의 프로세스 경우이다)**
- 프로세스 수행(Execution)
  - 부모와 자식은 공존하며 수행되는 모델이다.
  - 자식이 종료될 때까지 부모가 기다리는 모델이다.(**자식이 먼저 kill을 해야 부모도 kill을 할 수 있다**)
- 프로세스 종료(Termination)
  - 프로세스가 마지막 명령을 수행한 후 운영체제에게 알려준다(exit)
    - 자식이 부모에게 output data를 보낸다.
    - 프로세스의 각종 자원들이 운영체제에게 반납된다.
  - 특별한 경우에 부모 프로세스가 자식의 수행을 강제종료 시키는 경우도 있다(abort)
    1. 자식프로세스가 할당 자원의 한계치를 넘어서는 경우
    2. 자식 프로세스에게 할당된 태스크가 더이상 필요하지 않는 경우
    3. 부모가 종료하려는 경우(트리 구조에서 가장 아래에 있는 프로세스부터 종료된다)

